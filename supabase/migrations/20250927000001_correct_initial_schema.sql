/*
  # Function: check_if_admin
  This function checks if a user has the 'admin' role in their profile.

  ## Query Description: This function is crucial for enforcing role-based access control (RBAC). It queries the `profiles` table to see if the `role` column for the given user ID is set to 'admin'. It's designed to be used within Row Level Security (RLS) policies.
  
  ## Metadata:
  - Schema-Category: "Structural"
  - Impact-Level: "Low"
  - Requires-Backup: false
  - Reversible: true (can be dropped)
  
  ## Structure Details:
  - Creates a SQL function `check_if_admin(user_id uuid)`.
  
  ## Security Implications:
  - RLS Status: This function is a building block for RLS.
  - Policy Changes: No
  - Auth Requirements: Depends on the policy calling it.
  
  ## Performance Impact:
  - Indexes: The `profiles` table should have an index on the `id` column (which it does as a primary key).
  - Triggers: No
  - Estimated Impact: Low, as it's a simple lookup.
*/
create or replace function check_if_admin(user_id uuid)
returns boolean as $$
begin
  return exists (
    select 1
    from public.profiles
    where profiles.id = user_id and profiles.role = 'admin'
  );
end;
$$ language plpgsql security definer;


/*
  # Table: profiles
  Stores user profile data, extending the `auth.users` table.

  ## Query Description: This table holds public-facing user information and application-specific roles. It's linked one-to-one with `auth.users`. Creating this table is safe and will not affect existing data. It includes a 'role' column for RBAC.
  
  ## Metadata:
  - Schema-Category: "Structural"
  - Impact-Level: "Low"
  - Requires-Backup: false
  - Reversible: true (can be dropped)
  
  ## Structure Details:
  - Table: `public.profiles`
  - Columns: `id`, `updated_at`, `full_name`, `avatar_url`, `role`
  
  ## Security Implications:
  - RLS Status: Enabled.
  - Policy Changes: Yes, policies are created for this table.
  - Auth Requirements: `authenticated` users.
  
  ## Performance Impact:
  - Indexes: Primary key on `id`.
  - Triggers: A trigger is added to auto-create profiles.
  - Estimated Impact: Low.
*/
create table public.profiles (
  id uuid not null references auth.users on delete cascade,
  updated_at timestamp with time zone,
  full_name text,
  avatar_url text,
  role text default 'user',
  primary key (id)
);

-- RLS policies for profiles
alter table public.profiles enable row level security;

create policy "Profiles are viewable by everyone."
  on public.profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on public.profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update their own profile."
  on public.profiles for update
  using ( auth.uid() = id );

create policy "Admins can update any profile."
  on public.profiles for update
  using ( check_if_admin(auth.uid()) );

/*
  # Trigger: handle_new_user
  Automatically creates a profile entry when a new user signs up.

  ## Query Description: This trigger fires after a new user is created in `auth.users` and inserts a corresponding row into `public.profiles`. This ensures data consistency between authentication and application data.
  
  ## Metadata:
  - Schema-Category: "Structural"
  - Impact-Level: "Low"
  - Requires-Backup: false
  - Reversible: true (can be dropped)
  
  ## Structure Details:
  - Trigger on `auth.users` table.
  
  ## Security Implications:
  - RLS Status: N/A
  - Policy Changes: No
  - Auth Requirements: N/A
  
  ## Performance Impact:
  - Indexes: N/A
  - Triggers: Adds a trigger.
  - Estimated Impact: Minimal overhead on user creation.
*/
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

/*
  # Table: inventory_items
  Stores information about food inventory items.

  ## Query Description: This table will store all inventory items, linked to a user profile. RLS policies ensure users can only manage their own items, while admins have full access.
  
  ## Metadata:
  - Schema-Category: "Structural"
  - Impact-Level: "Medium"
  - Requires-Backup: false
  - Reversible: true
  
  ## Structure Details:
  - Table: `public.inventory_items`
  
  ## Security Implications:
  - RLS Status: Enabled.
  - Policy Changes: Yes.
  - Auth Requirements: `authenticated` users.
  
  ## Performance Impact:
  - Indexes: Primary key and foreign key index.
  - Triggers: No
  - Estimated Impact: Low.
*/
create table public.inventory_items (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  name text not null,
  category text,
  quantity numeric not null,
  unit text not null,
  expiration_date date,
  purchase_price numeric,
  storage_location text
);

-- RLS for inventory_items
alter table public.inventory_items enable row level security;

create policy "Users can manage their own inventory."
  on public.inventory_items for all
  using ( auth.uid() = user_id );

create policy "Admins can manage all inventory."
  on public.inventory_items for all
  using ( check_if_admin(auth.uid()) );

/*
  # Table: waste_logs
  Logs instances of food waste.

  ## Query Description: This table tracks food waste events, linking them to users. RLS policies restrict access to a user's own logs, with admins having full access.
  
  ## Metadata:
  - Schema-Category: "Structural"
  - Impact-Level: "Medium"
  - Requires-Backup: false
  - Reversible: true
  
  ## Structure Details:
  - Table: `public.waste_logs`
  
  ## Security Implications:
  - RLS Status: Enabled.
  - Policy Changes: Yes.
  - Auth Requirements: `authenticated` users.
  
  ## Performance Impact:
  - Indexes: Primary key and foreign key index.
  - Triggers: No
  - Estimated Impact: Low.
*/
create table public.waste_logs (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  item_name text not null,
  category text,
  quantity numeric not null,
  unit text not null,
  reason text,
  waste_date date not null,
  notes text
);

-- RLS for waste_logs
alter table public.waste_logs enable row level security;

create policy "Users can manage their own waste logs."
  on public.waste_logs for all
  using ( auth.uid() = user_id );

create policy "Admins can manage all waste logs."
  on public.waste_logs for all
  using ( check_if_admin(auth.uid()) );

/*
  # Table: marketplace_categories
  Stores categories for marketplace listings.

  ## Query Description: A simple table to categorize marketplace items. It's public and readable by everyone.
  
  ## Metadata:
  - Schema-Category: "Data"
  - Impact-Level: "Low"
  - Requires-Backup: false
  - Reversible: true
  
  ## Structure Details:
  - Table: `public.marketplace_categories`
  
  ## Security Implications:
  - RLS Status: Enabled.
  - Policy Changes: Yes.
  - Auth Requirements: Public access.
  
  ## Performance Impact:
  - Indexes: Primary key.
  - Triggers: No
  - Estimated Impact: Low.
*/
create table public.marketplace_categories (
  id bigint generated by default as identity primary key,
  name text not null unique,
  description text
);

-- RLS for marketplace_categories
alter table public.marketplace_categories enable row level security;

create policy "Categories are viewable by everyone."
  on public.marketplace_categories for select
  using ( true );

-- Seed categories
insert into public.marketplace_categories (name, description) values
('Produce', 'Fresh fruits and vegetables'),
('Dairy', 'Milk, cheese, yogurt, and other dairy products'),
('Bakery', 'Bread, pastries, and other baked goods'),
('Meat', 'Fresh and frozen meat and poultry'),
('Pantry', 'Non-perishable items'),
('Frozen', 'Frozen meals and ingredients');

/*
  # Table: marketplace_listings
  Stores items listed for sale on the marketplace.

  ## Query Description: This table holds all marketplace listings. Policies allow users to manage their own listings and view all listings, while admins have full control.
  
  ## Metadata:
  - Schema-Category: "Structural"
  - Impact-Level: "Medium"
  - Requires-Backup: false
  - Reversible: true
  
  ## Structure Details:
  - Table: `public.marketplace_listings`
  
  ## Security Implications:
  - RLS Status: Enabled.
  - Policy Changes: Yes.
  - Auth Requirements: `authenticated` users.
  
  ## Performance Impact:
  - Indexes: PK, FKs.
  - Triggers: No
  - Estimated Impact: Low.
*/
create table public.marketplace_listings (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles on delete cascade not null,
  category_id bigint references public.marketplace_categories on delete set null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  title text not null,
  description text,
  original_price numeric not null,
  discounted_price numeric not null,
  quantity text,
  location text,
  expires_at timestamp with time zone,
  image_url text,
  is_active boolean default true
);

-- RLS for marketplace_listings
alter table public.marketplace_listings enable row level security;

create policy "Listings are viewable by everyone."
  on public.marketplace_listings for select
  using ( is_active = true );

create policy "Users can insert their own listings."
  on public.marketplace_listings for insert
  with check ( auth.uid() = user_id );

create policy "Users can update their own listings."
  on public.marketplace_listings for update
  using ( auth.uid() = user_id );

create policy "Users can delete their own listings."
  on public.marketplace_listings for delete
  using ( auth.uid() = user_id );

create policy "Admins can manage all listings."
  on public.marketplace_listings for all
  using ( check_if_admin(auth.uid()) );
