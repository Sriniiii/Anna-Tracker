/*
          # Create Notifications Table
          This script creates the `notifications` table to store user-specific alerts and messages. It also enables Row Level Security (RLS) to ensure users can only access their own notifications.

          ## Query Description: This operation is safe and non-destructive. It adds a new `notifications` table and configures security policies. It will not affect any existing data.

          ## Metadata:
          - Schema-Category: ["Structural"]
          - Impact-Level: ["Low"]
          - Requires-Backup: [false]
          - Reversible: [true]
          
          ## Structure Details:
          - Table: `public.notifications`
          - Columns: `id`, `created_at`, `user_id`, `title`, `message`, `is_read`
          - Indexes: Primary key on `id`, index on `user_id`
          
          ## Security Implications:
          - RLS Status: Enabled
          - Policy Changes: Yes
          - Auth Requirements: Users must be authenticated to access their notifications.
          
          ## Performance Impact:
          - Indexes: Adds a primary key and a foreign key index.
          - Triggers: None
          - Estimated Impact: Low. Efficient queries on a per-user basis.
          */

-- 1. Create the notifications table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.notifications (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  is_read BOOLEAN DEFAULT FALSE NOT NULL,
  CONSTRAINT notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Add comments to the table and columns
COMMENT ON TABLE public.notifications IS 'Stores notifications for users.';
COMMENT ON COLUMN public.notifications.user_id IS 'The user who receives the notification.';
COMMENT ON COLUMN public.notifications.is_read IS 'Whether the user has read the notification.';

-- 2. Enable Row Level Security (RLS) on the table
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

-- 3. Create RLS policies
-- Allow users to read their own notifications
DROP POLICY IF EXISTS "Users can view their own notifications" ON public.notifications;
CREATE POLICY "Users can view their own notifications"
ON public.notifications FOR SELECT
USING (auth.uid() = user_id);

-- Allow users to update their own notifications (e.g., mark as read)
DROP POLICY IF EXISTS "Users can update their own notifications" ON public.notifications;
CREATE POLICY "Users can update their own notifications"
ON public.notifications FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- 4. Create a function to send a welcome notification
CREATE OR REPLACE FUNCTION public.handle_new_user_notification()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.notifications (user_id, title, message)
  VALUES (new.id, 'Welcome to BiteWise!', 'We are excited to have you on board. Start by adding items to your inventory or logging your first waste entry.');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 5. Create a trigger to call the function when a new user signs up
DROP TRIGGER IF EXISTS on_auth_user_created_send_welcome ON auth.users;
CREATE TRIGGER on_auth_user_created_send_welcome
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user_notification();
